use std::str::FromStr;

use ast::{Expr, Ident, Opcode, Stmt, StmtBlock};

grammar;

// Program top-level non-terminal
pub Program: StmtBlock = {
    Stmts,
};

// Stmts non-terminal: Stmt non-terminals separated by ";"
Stmts: StmtBlock = DelimitedList<Stmt, ";">;

// Macro matching any type T separated by a delimiter C
DelimitedList<T, C>: Vec<T> = {

    // Capture zero or more T followed by String C as "v"
    // Capture optional trailing T without a String C as "e"
    <v:(<T> C)*> <e:T?> => match e {

        // No trailing T, simply return "v"
        None => v,
        
        // Trailing T, push to "v" Vec
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        },
    },
};

// Statement non-terminal
Stmt: Box<Stmt> = {

    // Variable declarations
    "let" <Id> "=" <Expr> => Box::new(Stmt::Let(<>)),

    // Function definitions and related
    "fn" <Id> "(" <DelimitedList<Id, ",">> ")" "{" <Stmts> "}" => Box::new(Stmt::FnDef(<>)),
    "return" <Expr>                                            => Box::new(Stmt::Return(<>)),

    // Conditionals
    "if" <Expr> "{" <Stmts> "}"                        => Box::new(Stmt::If(<>)),
    "if" <Expr> "{" <Stmts> "}" "else" "{" <Stmts> "}" => Box::new(Stmt::IfElse(<>)),

    // Loops and related
    "loop" "{" <Stmts> "}" => Box::new(Stmt::Loop(<>)),
    "break"                => Box::new(Stmt::Break),

    // List element assignment
    <Id> "[" <Expr> "]" "=" <Expr> => Box::new(Stmt::ListItemAssignment(<>)),

    <Expr> => Box::new(Stmt::Expr(<>)),
};

// Expression non-terminal (precedence hierarchy Expr -> Term)
pub Expr: Box<Expr> = {
    LogicalExpr,
};

LogicalExpr: Box<Expr> = {

    // The Expr::BinOp variant takes three arguments (Box<Expr>, Opcode, Box<Expr>). Here, "<>"
    // refers to all three matching non-terminals as none of them are enclosed in <..>.
    LogicalExpr LogicalExprOp RelationalExpr => Box::new(Expr::BinOp(<>)),

    RelationalExpr,
};

LogicalExprOp: Opcode = {
    "&&" => Opcode::LogicalAnd,
    "||" => Opcode::LogicalOr,
    "^"  => Opcode::LogicalXor,
};

RelationalExpr: Box<Expr> = {
    RelationalExpr RelationalExprOp AdditiveExpr => Box::new(Expr::BinOp(<>)),
    AdditiveExpr,
};

RelationalExprOp: Opcode = {
    "<"  => Opcode::LessThan,
    ">"  => Opcode::GreaterThan,
    "<=" => Opcode::LessThanOrEqual,
    ">=" => Opcode::GreaterThanOrEqual,
    "==" => Opcode::Equal,
    "!=" => Opcode::NotEqual,
};

AdditiveExpr: Box<Expr> = {
    AdditiveExpr AdditiveExprOp MultiplicativeExpr => Box::new(Expr::BinOp(<>)),
    MultiplicativeExpr,
};

AdditiveExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

MultiplicativeExpr: Box<Expr> = {
    MultiplicativeExpr MultiplicativeExprOp Term => Box::new(Expr::BinOp(<>)),
    Term,
};

MultiplicativeExprOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

// Basic Term: literals, identifier, Expr in parentheses or a function invocation
Term: Box<Expr> = {
    IntNum      => Box::new(Expr::Int(<>)),
    RealNum     => Box::new(Expr::Real(<>)),
    LiteralStr  => Box::new(Expr::Str(<>)),
    LiteralBool => Box::new(Expr::Bool(<>)),
    Id          => Box::new(Expr::Id(<>)),
    "(" <Expr> ")",
    <Id> "(" <DelimitedList<Expr, ",">> ")" => Box::new(Expr::FuncCall(<>)),
    "[" <DelimitedList<Expr, ",">> "]" => Box::new(Expr::List(<>)),
    "{" <DelimitedList<KeyVal, ",">> "}" => Box::new(Expr::Dict(<>)),
    <Id> "[" <Expr> "]" => Box::new(Expr::ListElement(<>)),
    UnaryOp Term => Box::new(Expr::UnaryOp(<>)),
};

// Key (string) / value (expression) pair: used for constructing Dicts
KeyVal: (String, Box<Expr>) = {
    <LiteralStr> ":" <Expr> => (<>),
};

// Operators taking a single operand
UnaryOp: Opcode = {
    "!" => Opcode::Not,
};


// --- Terminals ---

// Any identifier
Id: Ident = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>),
};

// Basic signed integer (isize)
IntNum: isize = {
    r"-?[0-9]+" => isize::from_str(<>).unwrap(),
};

// Basic signed real (f64)
RealNum: f64 = {
    r"-?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),
};

// String literal
LiteralStr: String = {
    r#""[^"]*""# => <>.replace("\"", "").to_string(),
};

// Boolean literal
LiteralBool: bool = {
    "true"  => true,
    "false" => false,
};
